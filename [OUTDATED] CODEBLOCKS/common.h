//Если не определено, чтобы несколько раз файл не открывать
#ifndef COMMON_H
#define COMMON_H


#include <stdio.h>
//----Constants----
#define MAX_BEAM  1000 //Максимальное число участков
#define MAX_MAT   100  //Максимальное число материалов
#define MAX_SEC   100  //Максимальное число сечений
#define MAX_DISPL 100  //Максимальное число заданных перемещений
#define MAX_FORCE 100  //Максимальное число сосредоточенных сил
#define DEF_NDIV  3    //(2 по краям и 1 по середине элемента) Максимальное число разбиений по умолчанию чтобы понять что происходит внутри элемента

//Макс число степеней свободы
#define MAX_NDF ((MAX_BEAM + 1)*2)

//Полуширина ленты матрицы жесткостей
#define MAX_BAND 4

//-----Структуры данных---
struct MAT_INFO //Свойства материала
{
	double E; //2ная точность величины Модуль Юнга
	//double mu;
};

struct SEC_INFO //Параметры сечения
{
	double Ix; //Осевой момент инерции сечения
	double Wx; //Момент сопротивления сечения изгибу
};

struct BEAM_INFO //параметры участка
{
	double l;  //длина балки
	double p1; //распределенная нагрузка нагрузка в начале участка
	double p2; //нагрузка с правого торца
	int mat, sec; //номера материала и сечения
	int ndiv; //кол-во разбиений
};

struct DISPL_INFO //заданные перемещения
{
	int nd; //номер узла
	int df; //номер степени свободы
	double d; //величина перемещения
};

struct FORCE_INFO //заданные силы
{
	int nd;//номер узла
	int df;//номер степени свободы
	double f;//величина силы F или момента
};

struct RESULT_INFO //строка результатов
{
	double z; //координата от левого торца балки в глобальной системе
	double ie;//номер элемента
	double p;
	double Qy;
	double Mx;
	double theta;
	double v;
	double sigma;
};

//все входные данные поместим в структуру для удобства
//Входные данные задачи
struct INPUT_INFO
{
	//таблицы зад. перемещ, сил
	struct MAT_INFO mat[MAX_MAT]; // таблица материалов
	struct SEC_INFO sec[MAX_SEC]; // таблица сечений
	int n_beam; //число участков
	struct BEAM_INFO beam[MAX_BEAM];//таблица участков
	int n_displ;//число заданных перемещений
	struct DISPL_INFO displ[MAX_DISPL];//таблица перемещений
	int n_force;//число заданных сил
	struct FORCE_INFO force[MAX_FORCE];//таблица сосредоточенных сил
	int ndiv_cur;//текущее число разбиений
};

// Все что используется для решения задачи
//-- Структура состояния решателя---
struct SOLVE_INFO
{
	int ndf;//число степеней свободы задачи
	//векторы и матрицы для формирования решения СУ
	double K[MAX_NDF][MAX_BAND];//лента матрицы жесткостей //[MAX_NBAND]
	double F[MAX_NDF]; //вектор узловых сил и мометов
	double Q[MAX_NDF];//вектор узловых степеней свободы
};

//---------Подпрограммы-----------------
int input(FILE*in, struct INPUT_INFO*ii);//подпрограмма ввода исходных данных FILE*in - системная библиотека для обращения к файлам

//Подпрограмма формирования матрицы жетскостей элемента
int formke(const struct INPUT_INFO*ii, int ie, double K[4][4], double F[4]);

// подпрограмма формирования матрицы жесткостей конструкции
int formk(const struct INPUT_INFO*ii, struct SOLVE_INFO*si); //const struct INPUT_INFO*ii - указатель на структуру (*ii)
//указатель ищет данные по адресу в памяти (значение адреса)
//можем обращаться к полям si.ndf; или si->ndf по указателю начало структуры определяем и ищем в памяти положение поле ndf;
//при изменении поля ndf его значение в структуре сохранится
//при модификации аргументов функции, аргументы не сохраняются

//в разных структурах поля могут иметь одинаковые имена
//переменные, в которые записали структуру, обозвали по имени структуры Input Info = ii Solve Info = si и т.д.

//подпрограмма решения СЛАУ. Система независимая от исходных данных (все в солфинфо)
int solve(struct SOLVE_INFO*si);//указатель на структуру

//подпрограмма вычисления узловых сил, приходящихся на конкретный элемент Fe
int getfe(const struct INPUT_INFO*ii, const struct SOLVE_INFO*si, int ie, double Fe[4]); //результаты решения как константы

//подпрограмма вычисления результатов
int results(const struct INPUT_INFO*ii, const struct SOLVE_INFO*si, FILE*out);


#endif //COMMON_H
