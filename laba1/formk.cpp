
#include "common.h"
#include <memory.h> //для memset
#include <string.h>

//Подпрограмма формирования матрицы жетскостей элемента
int formke(const struct INPUT_INFO*ii, int ie, double K[4][4], double F[4])
{
	//не можем менять значения по указателю
	const struct BEAM_INFO*beam = ii->beam + ie;//текущий элемент
	double l = beam->l;
	double EIx = ii->mat[beam->mat].E*ii->sec[beam->sec].Ix;
	double dp = beam->p2 - beam->p1; //когда нагрузка линейно изменяется по элементам

	//ПРОВЕРИТЬ-----------------

	K[0][0] = K[2][2] = 12.0*EIx / l / l / l; //нули важно писать, т.к. при вычислении констант целочисленное деление, а с точкой вещественное деление
	K[0][1] = K[1][0] = K[0][3] = K[3][0] = 6.0*EIx / l / l;
	K[0][2] = K[2][0] = -K[0][0];
	K[1][1] = K[3][3] = 4.0*EIx / l;
	K[1][2] = K[2][1] = K[2][3] = K[3][2] = -K[0][1];
	K[1][3] = K[3][1] = K[1][1] / 2.0;
	//Правая часть от постоянной нагрузки
	F[0] = F[2] = beam->p1*l / 2.0;
	F[1] = beam->p1*l*l / 12.0;
	F[3] = -F[1];
	//Правая часть слагаемые от измен.нагрузки
	F[0] += dp * 3.0 / 20.0*l;
	F[1] += dp * 1.0 / 30.0*l*l;
	F[2] += dp * 7.0 / 20.0*l;
	F[3] += -dp * 1.0 / 20.0*l*l;
	return 0;
}


//ПРОВЕРИТЬ

// подпрограмма формирования матрицы жесткостей конструкции
int formk(const struct INPUT_INFO*ii, struct SOLVE_INFO*si)
{
	int ie, df, iv;
	const double L = 1e20; //параметр метода Аронса-Пейна точность -20 степень
						   //очистка матрицы
	memset(si, 0, sizeof(*si)); //очистка параметров решателя
								//число степеней свободы задачи
	si->ndf = (ii->n_beam + 1) * 2;
	for (ie = 0, df = 0; ie<ii->n_beam; ++ie, df += 2)
	{
		double Ke[4][4], Fe[4]; //матр. жесткостей
		int i, j;
		formke(ii, ie, Ke, Fe); //вычисление матрицы жесткостей отдельного элемента
		for (i = 0; i < 4; ++i) //цикл по строкам матрицы жесткостей элемента
		{
			si->F[df + i] += Fe[i];
			for (j = i; j < 4; ++j)//цикл по столбцам выше диагонали
			{
				si->K[df + i][j - i] += Ke[i][j]; //строка и столбец неотрицательные

			}
		}
	}
	for (iv = 0; iv < ii->n_force; ++iv) //цикл по заданным силам /моментам
	{
		int ndf = ii->force[iv].nd * 2 + ii->force[iv].df; //число степ своб*номер степ своб
		si->F[ndf] += ii->force[iv].f;//добавляемое значение силы

	}
	for (iv = 0; iv < ii->n_displ; ++iv)  //цикл по заданным перемещ/поворотам
	{
		int ndf = ii->displ[iv].nd * 2 + ii->displ[iv].df;
		si->K[ndf][0] = L; //Метод Айронса-Пейна
		si->F[ndf] = L * ii->displ[iv].d;
	}
	return 0;


}
